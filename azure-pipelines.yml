trigger:
  - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  MAVEN_CACHE_FOLDER: $(Pipeline.Workspace)/.m2/repository
  MAVEN_OPTS: '-Dmaven.repo.local=$(MAVEN_CACHE_FOLDER)'
  # IDs de tu Azure DevOps
  AZURE_DEVOPS_ORG: 'dontester'
  AZURE_DEVOPS_PROJECT: 'Automated Test Plan'
  TEST_PLAN_ID: 6
  TEST_SUITE_ID: 8

steps:
- task: JavaToolInstaller@0
  inputs:
    versionSpec: '17'
    jdkArchitectureOption: 'x64'
    jdkSourceOption: 'PreInstalled'
  displayName: 'Set up JDK 17'

- script: |
    mkdir -p $(MAVEN_CACHE_FOLDER)
  displayName: 'Create Maven cache directory'

- task: Cache@2
  inputs:
    key: 'maven | "$(Agent.OS)" | **/pom.xml'
    restoreKeys: |
      maven | "$(Agent.OS)"
    path: $(MAVEN_CACHE_FOLDER)
  displayName: 'Cache Maven packages'
  continueOnError: true

- task: Maven@4
  inputs:
    mavenPomFile: 'pom.xml'
    goals: 'clean test'
    options: '-Dkarate.env=qa'
    publishJUnitResults: false  # Desactivamos para publicar manualmente después
    javaHomeOption: 'JDKVersion'
    jdkVersionOption: '1.17'
    mavenVersionOption: 'Default'
  displayName: 'Run Karate Tests'
  continueOnError: true  # Continuar aunque los tests fallen

- script: |
    echo "========================================="
    echo "Verificando archivos generados..."
    echo "========================================="
    echo ""
    echo "Contenido de target/surefire-reports:"
    ls -la $(Build.SourcesDirectory)/target/surefire-reports/ || echo "Directory not found"
    echo ""
    echo "Archivos XML encontrados:"
    find $(Build.SourcesDirectory)/target -name "*.xml" -type f || echo "No XML files found"
    echo ""
    echo "Estructura completa de target:"
    ls -R $(Build.SourcesDirectory)/target/
  displayName: 'List Target Directory Contents'

- task: PublishTestResults@2
  condition: always()
  inputs:
    testResultsFormat: 'JUnit'
    testResultsFiles: '$(Build.SourcesDirectory)/target/surefire-reports/TEST-*.xml'
    searchFolder: '$(Build.SourcesDirectory)'
    mergeTestResults: true
    failTaskOnFailedTests: false
    testRunTitle: 'Karate Tests (Pipeline View Only)'
    buildPlatform: 'Karate'
    buildConfiguration: 'qa'
    publishRunAttachments: true
  displayName: 'Publish Test Results to Pipeline (for UI visibility only)'

# Script para asociar resultados con Azure Test Plan (con iteraciones)
- task: PowerShell@2
  condition: always()
  inputs:
    targetType: 'inline'
    script: |
      # Configuración
      $orgUrl = "https://dev.azure.com/$(AZURE_DEVOPS_ORG)"
      $project = "$(AZURE_DEVOPS_PROJECT)"
      $testPlanId = $(TEST_PLAN_ID)
      $testSuiteId = $(TEST_SUITE_ID)
      $pat = "$(System.AccessToken)"

      # Convertir PAT a Base64
      $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$($pat)"))
      $headers = @{
          "Authorization" = "Basic $base64AuthInfo"
          "Content-Type" = "application/json"
      }

      Write-Host "========================================"
      Write-Host "Creando Test Run para Test Plan $testPlanId..."
      Write-Host "========================================"

      # Crear Test Run
      $testRunBody = @{
          name = "Karate Automated Run - Build $(Build.BuildNumber)"
          plan = @{ id = $testPlanId }
          automated = $true
          build = @{ id = "$(Build.BuildId)" }
          buildPlatform = "Karate"
          buildFlavor = "qa"
      } | ConvertTo-Json -Depth 10

      $createRunUrl = "$orgUrl/$project/_apis/test/runs?api-version=7.0"
      $testRun = Invoke-RestMethod -Uri $createRunUrl -Method Post -Headers $headers -Body $testRunBody
      $testRunId = $testRun.id
      Write-Host "✓ Test Run creado con ID: $testRunId"

      # Leer resultados de Karate (archivo XML de surefire)
      $xmlFiles = Get-ChildItem -Path "$(Build.SourcesDirectory)/target/surefire-reports" -Filter "TEST-*.xml" -Recurse

      # Array para almacenar TODAS las iteraciones (sin consolidar)
      $allIterations = @()

      foreach ($xmlFile in $xmlFiles) {
          Write-Host "`nProcesando archivo: $($xmlFile.Name)"
          [xml]$xml = Get-Content $xmlFile.FullName

          $iterationCounter = @{}

          foreach ($testcase in $xml.testsuite.testcase) {
              $testName = $testcase.name
              $className = $testcase.classname

              # Extraer el TestCase ID del nombre del test
              if ($testName -match 'TC(\d+)_(.+?)\s') {
                  $testCaseId = [int]$Matches[1]  # Convertir a int
                  $testCaseTitle = "TC$($testCaseId)_" + $Matches[2].Trim()

                  # Contador de iteraciones por Test Case
                  if (-not $iterationCounter.ContainsKey($testCaseId)) {
                      $iterationCounter[$testCaseId] = 0
                  }
                  $iterationCounter[$testCaseId]++
                  $iterationNumber = $iterationCounter[$testCaseId]

                  # Extraer parámetros de la iteración del nombre del test
                  # Formato esperado: [1.X:YY] donde X es el número de iteración
                  $iterationParams = ""
                  if ($testName -match '\[1\.(\d+):') {
                      $exampleRow = $Matches[1]
                      $iterationParams = "Example Row $exampleRow"
                  }

                  $outcome = "Passed"
                  $errorMessage = ""
                  $stackTrace = ""

                  if ($testcase.failure) {
                      $outcome = "Failed"
                      $errorMessage = $testcase.failure.message
                      $stackTrace = $testcase.failure.'#text'
                  } elseif ($testcase.error) {
                      $outcome = "Failed"
                      $errorMessage = $testcase.error.message
                      $stackTrace = $testcase.error.'#text'
                  }

                  # Convertir duration de forma segura
                  $timeValue = $testcase.time
                  if ($timeValue -is [string]) {
                      $duration = [int]([double]::Parse($timeValue, [System.Globalization.CultureInfo]::InvariantCulture) * 1000)
                  } else {
                      $duration = [int]([double]$timeValue * 1000)
                  }

                  Write-Host "  [$iterationNumber] Test Case $testCaseId - $outcome ($duration ms) - $iterationParams"

                  # Agregar cada iteración como un resultado separado
                  $allIterations += @{
                      testCaseId = $testCaseId
                      testCaseTitle = $testCaseTitle
                      iterationNumber = $iterationNumber
                      iterationParams = $iterationParams
                      outcome = $outcome
                      errorMessage = $errorMessage
                      stackTrace = $stackTrace
                      duration = $duration
                      automatedTestName = "$testCaseTitle - Iteration $iterationNumber"
                  }
              }
          }
      }

      Write-Host "`n========================================"
      Write-Host "Total de iteraciones encontradas: $($allIterations.Count)"

      # Agrupar por Test Case para mostrar resumen
      $summary = $allIterations | Group-Object -Property testCaseId
      foreach ($group in $summary) {
          $passed = ($group.Group | Where-Object { $_.outcome -eq "Passed" }).Count
          $failed = ($group.Group | Where-Object { $_.outcome -eq "Failed" }).Count
          Write-Host "  Test Case $($group.Name): $($group.Count) iteraciones ($passed passed, $failed failed)"
      }
      Write-Host "========================================"

      # Obtener Test Points para el Test Suite (incluir workItemProperties para obtener revision)
      $testPointsUrl = "$orgUrl/$project/_apis/test/plans/$testPlanId/suites/$testSuiteId/points?includePointDetails=true&api-version=7.0"
      $testPoints = Invoke-RestMethod -Uri $testPointsUrl -Method Get -Headers $headers
      Write-Host "`n✓ Test Points obtenidos: $($testPoints.count)"

      # Crear array de resultados para publicar (UNA entrada por CADA iteración)
      $resultsToPublish = @()

      foreach ($iteration in $allIterations) {
          # Buscar el Test Point correspondiente
          $testPoint = $testPoints.value | Where-Object {
              $_.testCase.id -eq $iteration.testCaseId
          } | Select-Object -First 1

          if ($testPoint) {
              # Obtener información del Test Case desde el Test Point
              $testCaseRef = $testPoint.testCase

              # Obtener detalles completos del Test Case para revision
              $testCaseUrl = "$orgUrl/$project/_apis/wit/workitems/$($iteration.testCaseId)?api-version=7.0"
              try {
                  $testCaseDetails = Invoke-RestMethod -Uri $testCaseUrl -Method Get -Headers $headers
                  $testCaseRevision = $testCaseDetails.rev
              } catch {
                  Write-Host "⚠ No se pudo obtener revision para Test Case $($iteration.testCaseId), usando 1 por defecto"
                  $testCaseRevision = 1
              }

              # Crear resultado con información de iteración (incluyendo campos requeridos por Azure DevOps)
              $resultData = @{
                  testCase = @{
                      id = [string]$iteration.testCaseId  # Debe ser string según API
                  }
                  testCaseTitle = $iteration.testCaseTitle
                  testCaseRevision = $testCaseRevision  # Campo requerido
                  testPoint = @{ id = [string]$testPoint.id }  # Debe ser string
                  outcome = $iteration.outcome
                  state = "Completed"
                  durationInMs = $iteration.duration
                  automatedTestName = $iteration.automatedTestName
                  comment = "Iteration $($iteration.iterationNumber) - $($iteration.iterationParams)"
              }

              # Agregar mensaje de error si existe
              if ($iteration.errorMessage) {
                  $resultData.errorMessage = $iteration.errorMessage
              }

              # Agregar stack trace si existe
              if ($iteration.stackTrace) {
                  $resultData.stackTrace = $iteration.stackTrace
              }

              $resultsToPublish += $resultData
          } else {
              Write-Host "⚠ WARNING: No se encontró Test Point para Test Case ID: $($iteration.testCaseId)"
          }
      }

      if ($resultsToPublish.Count -gt 0) {
          Write-Host "`n========================================"
          Write-Host "Publicando $($resultsToPublish.Count) resultados al Test Run..."
          Write-Host "========================================"

          # Azure DevOps tiene un límite de ~200 resultados por request
          # Dividir en lotes si es necesario
          $batchSize = 100
          $totalBatches = [Math]::Ceiling($resultsToPublish.Count / $batchSize)

          for ($i = 0; $i -lt $totalBatches; $i++) {
              $start = $i * $batchSize
              $end = [Math]::Min(($i + 1) * $batchSize, $resultsToPublish.Count)
              $batch = $resultsToPublish[$start..($end-1)]

              Write-Host "  Publicando lote $($i+1)/$totalBatches ($($batch.Count) resultados)..."

              $publishBody = $batch | ConvertTo-Json -Depth 10
              $publishUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/results?api-version=7.0"

              try {
                  # Debug: Mostrar el primer resultado para verificar formato
                  if ($i -eq 0) {
                      Write-Host "  Sample result (first item):"
                      Write-Host ($batch[0] | ConvertTo-Json -Depth 5)
                  }

                  $publishedResults = Invoke-RestMethod -Uri $publishUrl -Method Post -Headers $headers -Body $publishBody
                  Write-Host "  ✓ Lote $($i+1) publicado exitosamente"
              } catch {
                  Write-Host "  ✗ Error al publicar lote $($i+1): $($_.Exception.Message)"
                  Write-Host "  Response: $($_.Exception.Response)"
                  if ($_.ErrorDetails.Message) {
                      Write-Host "  Error Details: $($_.ErrorDetails.Message)"
                  }
              }
          }

          Write-Host "`n✓ Todos los resultados publicados"

          # Adjuntar reportes de Karate al Test Run (en formato ZIP)
          Write-Host "`n========================================"
          Write-Host "Creando y adjuntando reportes de Karate al Test Run..."
          Write-Host "========================================"

          $targetPath = "$(Build.SourcesDirectory)/target"
          $tempZipPath = "$(Build.SourcesDirectory)/temp-zips"

          # Crear directorio temporal para ZIPs
          New-Item -ItemType Directory -Force -Path $tempZipPath | Out-Null

          # 1. Comprimir karate.log
          $karateLogPath = Join-Path $targetPath "karate.log"
          if (Test-Path $karateLogPath) {
              try {
                  $karateLogZip = Join-Path $tempZipPath "karate-log.zip"
                  Compress-Archive -Path $karateLogPath -DestinationPath $karateLogZip -Force
                  Write-Host "  ✓ Creado: karate-log.zip"

                  # Adjuntar al Test Run
                  $fileContent = [System.IO.File]::ReadAllBytes($karateLogZip)
                  $base64Content = [System.Convert]::ToBase64String($fileContent)
                  $attachmentBody = @{
                      stream = $base64Content
                      fileName = "karate-log.zip"
                      comment = "Karate Execution Log"
                      attachmentType = "GeneralAttachment"
                  } | ConvertTo-Json
                  $attachmentUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/attachments?api-version=7.0"
                  Invoke-RestMethod -Uri $attachmentUrl -Method Post -Headers $headers -Body $attachmentBody | Out-Null
                  Write-Host "  ✓ Adjuntado: karate-log.zip al Test Run"
              } catch {
                  Write-Host "  ⚠ Error con karate-log.zip: $($_.Exception.Message)"
              }
          } else {
              Write-Host "  ⚠ No se encontró: karate.log"
          }

          # 2. Comprimir cucumber-reports/
          $cucumberReportsPath = Join-Path $targetPath "cucumber-reports"
          if (Test-Path $cucumberReportsPath) {
              try {
                  $cucumberReportsZip = Join-Path $tempZipPath "cucumber-reports.zip"
                  Compress-Archive -Path "$cucumberReportsPath/*" -DestinationPath $cucumberReportsZip -Force
                  Write-Host "  ✓ Creado: cucumber-reports.zip"

                  # Adjuntar al Test Run
                  $fileContent = [System.IO.File]::ReadAllBytes($cucumberReportsZip)
                  $base64Content = [System.Convert]::ToBase64String($fileContent)
                  $attachmentBody = @{
                      stream = $base64Content
                      fileName = "cucumber-reports.zip"
                      comment = "Karate HTML Reports"
                      attachmentType = "GeneralAttachment"
                  } | ConvertTo-Json
                  $attachmentUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/attachments?api-version=7.0"
                  Invoke-RestMethod -Uri $attachmentUrl -Method Post -Headers $headers -Body $attachmentBody | Out-Null
                  Write-Host "  ✓ Adjuntado: cucumber-reports.zip al Test Run"
              } catch {
                  Write-Host "  ⚠ Error con cucumber-reports.zip: $($_.Exception.Message)"
              }
          } else {
              Write-Host "  ⚠ No se encontró: cucumber-reports/"
          }

          # Limpiar directorio temporal
          Remove-Item -Path $tempZipPath -Recurse -Force -ErrorAction SilentlyContinue

          Write-Host "`n✓ Reportes comprimidos y adjuntados al Test Run"

          # Completar el Test Run
          Write-Host "`nCompletando Test Run $testRunId..."
          $updateRunBody = @{
              state = "Completed"
          } | ConvertTo-Json

          $updateRunUrl = "$orgUrl/$project/_apis/test/runs/$($testRunId)?api-version=7.0"
          Write-Host "URL: $updateRunUrl"

          try {
              Invoke-RestMethod -Uri $updateRunUrl -Method Patch -Headers $headers -Body $updateRunBody
              Write-Host "✓ Test Run $testRunId completado"
          } catch {
              Write-Host "⚠ Error al completar Test Run: $($_.Exception.Message)"
          }

          Write-Host "`n========================================"
          Write-Host "RESUMEN FINAL:"
          Write-Host "========================================"
          Write-Host "Test Run ID: $testRunId"
          Write-Host "Total Iteraciones: $($allIterations.Count)"
          Write-Host "URL: $orgUrl/$project/_testManagement/runs?runId=$testRunId&_a=resultSummary"
          Write-Host "========================================"
      } else {
          Write-Host "✗ ERROR: No se encontraron resultados para publicar"
          exit 1
      }
  displayName: 'Associate Test Results with Azure Test Plan'
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)

- task: PublishBuildArtifacts@1
  condition: always()
  inputs:
    PathtoPublish: '$(Build.SourcesDirectory)/target'
    ArtifactName: 'test-reports'
    publishLocation: 'Container'
  displayName: 'Publish All Test Reports'
