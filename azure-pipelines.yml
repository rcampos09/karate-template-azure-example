trigger:
  - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  MAVEN_CACHE_FOLDER: $(Pipeline.Workspace)/.m2/repository
  MAVEN_OPTS: '-Dmaven.repo.local=$(MAVEN_CACHE_FOLDER)'
  # IDs de tu Azure DevOps
  AZURE_DEVOPS_ORG: 'dontester'
  AZURE_DEVOPS_PROJECT: 'Automated Test Plan'
  TEST_PLAN_ID: 6
  TEST_SUITE_ID: 8

steps:
- task: JavaToolInstaller@0
  inputs:
    versionSpec: '17'
    jdkArchitectureOption: 'x64'
    jdkSourceOption: 'PreInstalled'
  displayName: 'Set up JDK 17'

- script: |
    mkdir -p $(MAVEN_CACHE_FOLDER)
  displayName: 'Create Maven cache directory'

- task: Cache@2
  inputs:
    key: 'maven | "$(Agent.OS)" | **/pom.xml'
    restoreKeys: |
      maven | "$(Agent.OS)"
    path: $(MAVEN_CACHE_FOLDER)
  displayName: 'Cache Maven packages'
  continueOnError: true

- task: Maven@4
  inputs:
    mavenPomFile: 'pom.xml'
    goals: 'clean test'
    options: '-Dkarate.env=qa'
    publishJUnitResults: false  # Desactivamos para publicar manualmente después
    javaHomeOption: 'JDKVersion'
    jdkVersionOption: '1.17'
    mavenVersionOption: 'Default'
  displayName: 'Run Karate Tests'
  continueOnError: true  # Continuar aunque los tests fallen

- script: |
    echo "========================================="
    echo "Verificando archivos generados..."
    echo "========================================="
    echo ""
    echo "Contenido de target/surefire-reports:"
    ls -la $(Build.SourcesDirectory)/target/surefire-reports/ || echo "Directory not found"
    echo ""
    echo "Archivos XML encontrados:"
    find $(Build.SourcesDirectory)/target -name "*.xml" -type f || echo "No XML files found"
    echo ""
    echo "Estructura completa de target:"
    ls -R $(Build.SourcesDirectory)/target/
  displayName: 'List Target Directory Contents'

# Script para asociar resultados con Azure Test Plan (con iteraciones)
- task: PowerShell@2
  condition: always()
  inputs:
    targetType: 'inline'
    script: |
      # Configuración
      $orgUrl = "https://dev.azure.com/$(AZURE_DEVOPS_ORG)"
      $project = "$(AZURE_DEVOPS_PROJECT)"
      $testPlanId = $(TEST_PLAN_ID)
      $testSuiteId = $(TEST_SUITE_ID)
      $pat = "$(System.AccessToken)"

      # Convertir PAT a Base64
      $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$($pat)"))
      $headers = @{
          "Authorization" = "Basic $base64AuthInfo"
          "Content-Type" = "application/json"
      }

      Write-Host "========================================"
      Write-Host "Creando Test Run para Test Plan $testPlanId..."
      Write-Host "========================================"

      # Crear Test Run con configuración
      $testRunBody = @{
          name = "Karate Automated Run - Build $(Build.BuildNumber)"
          plan = @{ id = $testPlanId }
          automated = $true
          build = @{ id = "$(Build.BuildId)" }
          buildPlatform = "Karate"
          buildFlavor = "qa"
          configurationIds = @()  # Se puede agregar ID de configuración si existe
          comment = "Automated test execution from Azure Pipeline"
      } | ConvertTo-Json -Depth 10

      $createRunUrl = "$orgUrl/$project/_apis/test/runs?api-version=7.0"
      $testRun = Invoke-RestMethod -Uri $createRunUrl -Method Post -Headers $headers -Body $testRunBody
      $testRunId = $testRun.id
      Write-Host "✓ Test Run creado con ID: $testRunId"

      # Leer el feature file para obtener los parámetros de Examples
      Write-Host "`nExtrayendo parámetros del feature file..."
      $featureFile = "$(Build.SourcesDirectory)/src/test/java/examples/users/TC12345_ValidarLogin.feature"
      $featureContent = Get-Content $featureFile -Raw

      # Parsear los parámetros de cada Test Case del feature file
      $testDataMap = @{}

      # Función para extraer datos de Examples de un Scenario Outline
      function Parse-ExamplesTable {
          param($content, $testCaseId)

          # Buscar el bloque de Examples para este Test Case
          $pattern = "@TestCase=$testCaseId[\s\S]*?Examples:\s*\|(.*?)\|([\s\S]*?)(?=@TestCase|\z)"
          if ($content -match $pattern) {
              $headerLine = $Matches[1].Trim()
              $dataLines = $Matches[2].Trim()

              # Extraer nombres de columnas
              $columns = $headerLine -split '\|' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }

              # Extraer filas de datos
              $rows = @()
              $dataLines -split "`n" | Where-Object { $_ -match '\|' } | ForEach-Object {
                  $values = $_ -split '\|' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
                  if ($values.Count -gt 0) {
                      $row = @{}
                      for ($i = 0; $i -lt $columns.Count; $i++) {
                          $row[$columns[$i]] = $values[$i]
                      }
                      $rows += $row
                  }
              }
              return $rows
          }
          return @()
      }

      # Extraer parámetros para cada Test Case
      $testDataMap[9] = Parse-ExamplesTable -content $featureContent -testCaseId 9
      $testDataMap[10] = Parse-ExamplesTable -content $featureContent -testCaseId 10
      $testDataMap[11] = Parse-ExamplesTable -content $featureContent -testCaseId 11

      Write-Host "  TC9: $($testDataMap[9].Count) ejemplos extraídos"
      Write-Host "  TC10: $($testDataMap[10].Count) ejemplos extraídos"
      Write-Host "  TC11: $($testDataMap[11].Count) ejemplos extraídos"

      # Leer resultados de Karate (archivo XML de surefire)
      $xmlFiles = Get-ChildItem -Path "$(Build.SourcesDirectory)/target/surefire-reports" -Filter "TEST-*.xml" -Recurse

      # Array para almacenar TODAS las iteraciones (sin consolidar)
      $allIterations = @()

      foreach ($xmlFile in $xmlFiles) {
          Write-Host "`nProcesando archivo: $($xmlFile.Name)"
          [xml]$xml = Get-Content $xmlFile.FullName

          $iterationCounter = @{}

          foreach ($testcase in $xml.testsuite.testcase) {
              $testName = $testcase.name
              $className = $testcase.classname

              # Extraer el TestCase ID del nombre del test
              if ($testName -match 'TC(\d+)_(.+?)\s') {
                  $testCaseId = [int]$Matches[1]  # Convertir a int
                  $testCaseTitle = "TC$($testCaseId)_" + $Matches[2].Trim()

                  # Contador de iteraciones por Test Case
                  if (-not $iterationCounter.ContainsKey($testCaseId)) {
                      $iterationCounter[$testCaseId] = 0
                  }
                  $iterationCounter[$testCaseId]++
                  $iterationNumber = $iterationCounter[$testCaseId]

                  $outcome = "Passed"
                  $errorMessage = ""
                  $stackTrace = ""

                  if ($testcase.failure) {
                      $outcome = "Failed"
                      $errorMessage = $testcase.failure.message
                      $stackTrace = $testcase.failure.'#text'
                  } elseif ($testcase.error) {
                      $outcome = "Failed"
                      $errorMessage = $testcase.error.message
                      $stackTrace = $testcase.error.'#text'
                  }

                  # Convertir duration de forma segura
                  $timeValue = $testcase.time
                  if ($timeValue -is [string]) {
                      $duration = [int]([double]::Parse($timeValue, [System.Globalization.CultureInfo]::InvariantCulture) * 1000)
                  } else {
                      $duration = [int]([double]$timeValue * 1000)
                  }

                  # Obtener parámetros de la tabla Examples
                  $testData = $null
                  $iterationParams = ""
                  $detailedComment = ""

                  if ($testDataMap.ContainsKey($testCaseId) -and $testDataMap[$testCaseId].Count -ge $iterationNumber) {
                      $testData = $testDataMap[$testCaseId][$iterationNumber - 1]

                      # Crear comentario detallado basado en el Test Case
                      $statusIcon = if ($outcome -eq "Passed") { "✓" } else { "✗" }

                      if ($testCaseId -eq 9) {
                          # TC9: Login exitoso
                          $iterationParams = "Email: $($testData.email)"
                          $detailedComment = "$statusIcon TC9 - Iteración $iterationNumber/6: Login exitoso`n" +
                                            "  • Email: $($testData.email)`n" +
                                            "  • Password: $($testData.password)`n" +
                                            "  • Status esperado: $($testData.expectedStatus)`n" +
                                            "  • Timeout: $($testData.timeout)ms`n" +
                                            "  • Duración real: $($duration)ms"
                      } elseif ($testCaseId -eq 10) {
                          # TC10: Login fallido
                          $iterationParams = "Email: $($testData.email)"
                          $detailedComment = "$statusIcon TC10 - Iteración $iterationNumber/6: Login fallido esperado`n" +
                                            "  • Email: $($testData.email)`n" +
                                            "  • Password: $($testData.password)`n" +
                                            "  • Status esperado: $($testData.expectedStatus)`n" +
                                            "  • Duración: $($duration)ms"
                      } elseif ($testCaseId -eq 11) {
                          # TC11: Crear usuario
                          $iterationParams = "Name: $($testData.name), Job: $($testData.job)"
                          $detailedComment = "$statusIcon TC11 - Iteración $iterationNumber/6: Usuario creado`n" +
                                            "  • Name: $($testData.name)`n" +
                                            "  • Job: $($testData.job)`n" +
                                            "  • Status esperado: $($testData.expectedStatus)`n" +
                                            "  • Duración: $($duration)ms"
                      }
                  } else {
                      $iterationParams = "Iteration $iterationNumber"
                      $detailedComment = "Iteration $iterationNumber - $outcome"
                  }

                  Write-Host "  [$iterationNumber] Test Case $testCaseId - $outcome ($duration ms) - $iterationParams"

                  # Agregar cada iteración como un resultado separado
                  $allIterations += @{
                      testCaseId = $testCaseId
                      testCaseTitle = $testCaseTitle
                      iterationNumber = $iterationNumber
                      iterationParams = $iterationParams
                      detailedComment = $detailedComment
                      outcome = $outcome
                      errorMessage = $errorMessage
                      stackTrace = $stackTrace
                      duration = $duration
                      automatedTestName = "$testCaseTitle - Iteration $iterationNumber"
                  }
              }
          }
      }

      Write-Host "`n========================================"
      Write-Host "Total de iteraciones encontradas: $($allIterations.Count)"

      # Agrupar por Test Case para mostrar resumen
      $summary = $allIterations | Group-Object -Property testCaseId
      foreach ($group in $summary) {
          $passed = ($group.Group | Where-Object { $_.outcome -eq "Passed" }).Count
          $failed = ($group.Group | Where-Object { $_.outcome -eq "Failed" }).Count
          Write-Host "  Test Case $($group.Name): $($group.Count) iteraciones ($passed passed, $failed failed)"
      }
      Write-Host "========================================"

      # Obtener Test Points para el Test Suite (incluir workItemProperties para obtener revision)
      $testPointsUrl = "$orgUrl/$project/_apis/test/plans/$testPlanId/suites/$testSuiteId/points?includePointDetails=true&api-version=7.0"
      $testPoints = Invoke-RestMethod -Uri $testPointsUrl -Method Get -Headers $headers
      Write-Host "`n✓ Test Points obtenidos: $($testPoints.count)"

      # Crear array de resultados para publicar (UNA entrada por CADA iteración)
      $resultsToPublish = @()

      foreach ($iteration in $allIterations) {
          # Buscar el Test Point correspondiente
          $testPoint = $testPoints.value | Where-Object {
              $_.testCase.id -eq $iteration.testCaseId
          } | Select-Object -First 1

          if ($testPoint) {
              # Obtener información del Test Case desde el Test Point
              $testCaseRef = $testPoint.testCase

              # Obtener detalles completos del Test Case para revision
              $testCaseUrl = "$orgUrl/$project/_apis/wit/workitems/$($iteration.testCaseId)?api-version=7.0"
              try {
                  $testCaseDetails = Invoke-RestMethod -Uri $testCaseUrl -Method Get -Headers $headers
                  $testCaseRevision = $testCaseDetails.rev
              } catch {
                  Write-Host "⚠ No se pudo obtener revision para Test Case $($iteration.testCaseId), usando 1 por defecto"
                  $testCaseRevision = 1
              }

              # Crear resultado con información de iteración (incluyendo campos requeridos por Azure DevOps)
              $resultData = @{
                  testCase = @{
                      id = [string]$iteration.testCaseId  # Debe ser string según API
                  }
                  testCaseTitle = $iteration.testCaseTitle
                  testCaseRevision = $testCaseRevision  # Campo requerido
                  testPoint = @{ id = [string]$testPoint.id }  # Debe ser string
                  outcome = $iteration.outcome
                  state = "Completed"
                  durationInMs = $iteration.duration
                  automatedTestName = $iteration.automatedTestName
                  comment = $iteration.detailedComment  # Comentario detallado con parámetros del test
                  # Campos adicionales para mostrar en Test Results
                  priority = if ($testPoint.priority) { $testPoint.priority } else { 2 }  # Priority por defecto: 2
                  owner = if ($testPoint.assignedTo) { $testPoint.assignedTo } else { $null }
                  configuration = @{ name = "qa" }  # Configuración del ambiente
                  iterationDetails = @( @{
                      id = $iteration.iterationNumber
                      outcome = $iteration.outcome
                      duration = $iteration.duration
                  } )
              }

              # Agregar mensaje de error si existe
              if ($iteration.errorMessage) {
                  $resultData.errorMessage = $iteration.errorMessage
              }

              # Agregar stack trace si existe
              if ($iteration.stackTrace) {
                  $resultData.stackTrace = $iteration.stackTrace
              }

              $resultsToPublish += $resultData
          } else {
              Write-Host "⚠ WARNING: No se encontró Test Point para Test Case ID: $($iteration.testCaseId)"
          }
      }

      if ($resultsToPublish.Count -gt 0) {
          Write-Host "`n========================================"
          Write-Host "Publicando $($resultsToPublish.Count) resultados al Test Run..."
          Write-Host "========================================"

          # Azure DevOps tiene un límite de ~200 resultados por request
          # Dividir en lotes si es necesario
          $batchSize = 100
          $totalBatches = [Math]::Ceiling($resultsToPublish.Count / $batchSize)

          for ($i = 0; $i -lt $totalBatches; $i++) {
              $start = $i * $batchSize
              $end = [Math]::Min(($i + 1) * $batchSize, $resultsToPublish.Count)
              $batch = $resultsToPublish[$start..($end-1)]

              Write-Host "  Publicando lote $($i+1)/$totalBatches ($($batch.Count) resultados)..."

              $publishBody = $batch | ConvertTo-Json -Depth 10
              $publishUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/results?api-version=7.0"

              try {
                  # Debug: Mostrar el primer resultado para verificar formato
                  if ($i -eq 0) {
                      Write-Host "  Sample result (first item):"
                      Write-Host ($batch[0] | ConvertTo-Json -Depth 5)
                  }

                  $publishedResults = Invoke-RestMethod -Uri $publishUrl -Method Post -Headers $headers -Body $publishBody
                  Write-Host "  ✓ Lote $($i+1) publicado exitosamente"
              } catch {
                  Write-Host "  ✗ Error al publicar lote $($i+1): $($_.Exception.Message)"
                  Write-Host "  Response: $($_.Exception.Response)"
                  if ($_.ErrorDetails.Message) {
                      Write-Host "  Error Details: $($_.ErrorDetails.Message)"
                  }
              }
          }

          Write-Host "`n✓ Todos los resultados publicados"

          # Adjuntar reportes de Karate al Test Run (en formato ZIP)
          Write-Host "`n========================================"
          Write-Host "Creando y adjuntando reportes de Karate al Test Run..."
          Write-Host "========================================"

          $targetPath = "$(Build.SourcesDirectory)/target"
          $tempZipPath = "$(Build.SourcesDirectory)/temp-zips"

          # Crear directorio temporal para ZIPs
          New-Item -ItemType Directory -Force -Path $tempZipPath | Out-Null

          # 1. Comprimir karate.log
          $karateLogPath = Join-Path $targetPath "karate.log"
          if (Test-Path $karateLogPath) {
              try {
                  $karateLogZip = Join-Path $tempZipPath "karate-log.zip"
                  Compress-Archive -Path $karateLogPath -DestinationPath $karateLogZip -Force
                  Write-Host "  ✓ Creado: karate-log.zip"

                  # Adjuntar al Test Run
                  $fileContent = [System.IO.File]::ReadAllBytes($karateLogZip)
                  $base64Content = [System.Convert]::ToBase64String($fileContent)
                  $attachmentBody = @{
                      stream = $base64Content
                      fileName = "karate-log.zip"
                      comment = "Karate Execution Log"
                      attachmentType = "GeneralAttachment"
                  } | ConvertTo-Json
                  $attachmentUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/attachments?api-version=7.0"
                  Invoke-RestMethod -Uri $attachmentUrl -Method Post -Headers $headers -Body $attachmentBody | Out-Null
                  Write-Host "  ✓ Adjuntado: karate-log.zip al Test Run"
              } catch {
                  Write-Host "  ⚠ Error con karate-log.zip: $($_.Exception.Message)"
              }
          } else {
              Write-Host "  ⚠ No se encontró: karate.log"
          }

          # 2. Comprimir cucumber-reports/
          $cucumberReportsPath = Join-Path $targetPath "cucumber-reports"
          if (Test-Path $cucumberReportsPath) {
              try {
                  $cucumberReportsZip = Join-Path $tempZipPath "cucumber-reports.zip"
                  Compress-Archive -Path "$cucumberReportsPath/*" -DestinationPath $cucumberReportsZip -Force
                  Write-Host "  ✓ Creado: cucumber-reports.zip"

                  # Adjuntar al Test Run
                  $fileContent = [System.IO.File]::ReadAllBytes($cucumberReportsZip)
                  $base64Content = [System.Convert]::ToBase64String($fileContent)
                  $attachmentBody = @{
                      stream = $base64Content
                      fileName = "cucumber-reports.zip"
                      comment = "Karate HTML Reports"
                      attachmentType = "GeneralAttachment"
                  } | ConvertTo-Json
                  $attachmentUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/attachments?api-version=7.0"
                  Invoke-RestMethod -Uri $attachmentUrl -Method Post -Headers $headers -Body $attachmentBody | Out-Null
                  Write-Host "  ✓ Adjuntado: cucumber-reports.zip al Test Run"
              } catch {
                  Write-Host "  ⚠ Error con cucumber-reports.zip: $($_.Exception.Message)"
              }
          } else {
              Write-Host "  ⚠ No se encontró: cucumber-reports/"
          }

          # Limpiar directorio temporal
          Remove-Item -Path $tempZipPath -Recurse -Force -ErrorAction SilentlyContinue

          Write-Host "`n✓ Reportes comprimidos y adjuntados al Test Run"

          # Completar el Test Run
          Write-Host "`nCompletando Test Run $testRunId..."
          $updateRunBody = @{
              state = "Completed"
          } | ConvertTo-Json

          $updateRunUrl = "$orgUrl/$project/_apis/test/runs/$($testRunId)?api-version=7.0"
          Write-Host "URL: $updateRunUrl"

          try {
              Invoke-RestMethod -Uri $updateRunUrl -Method Patch -Headers $headers -Body $updateRunBody
              Write-Host "✓ Test Run $testRunId completado"
          } catch {
              Write-Host "⚠ Error al completar Test Run: $($_.Exception.Message)"
          }

          Write-Host "`n========================================"
          Write-Host "RESUMEN FINAL:"
          Write-Host "========================================"
          Write-Host "Test Run ID: $testRunId"
          Write-Host "Total Iteraciones: $($allIterations.Count)"
          Write-Host "URL: $orgUrl/$project/_testManagement/runs?runId=$testRunId&_a=resultSummary"
          Write-Host "========================================"
      } else {
          Write-Host "✗ ERROR: No se encontraron resultados para publicar"
          exit 1
      }
  displayName: 'Associate Test Results with Azure Test Plan'
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)

- task: PublishBuildArtifacts@1
  condition: always()
  inputs:
    PathtoPublish: '$(Build.SourcesDirectory)/target'
    ArtifactName: 'test-reports'
    publishLocation: 'Container'
  displayName: 'Publish All Test Reports'
