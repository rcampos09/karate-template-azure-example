trigger:
  - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  MAVEN_CACHE_FOLDER: $(Pipeline.Workspace)/.m2/repository
  MAVEN_OPTS: '-Dmaven.repo.local=$(MAVEN_CACHE_FOLDER)'
  # IDs de tu Azure DevOps
  AZURE_DEVOPS_ORG: 'dontester'
  AZURE_DEVOPS_PROJECT: 'Automated Test Plan'
  TEST_PLAN_ID: 6
  TEST_SUITE_ID: 8

steps:
# Checkout con permisos para hacer push
- checkout: self
  persistCredentials: true
  displayName: 'Checkout repository with write permissions'

- task: JavaToolInstaller@0
  inputs:
    versionSpec: '17'
    jdkArchitectureOption: 'x64'
    jdkSourceOption: 'PreInstalled'
  displayName: 'Set up JDK 17'

- script: |
    mkdir -p $(MAVEN_CACHE_FOLDER)
  displayName: 'Create Maven cache directory'

- task: Cache@2
  inputs:
    key: 'maven | "$(Agent.OS)" | **/pom.xml'
    restoreKeys: |
      maven | "$(Agent.OS)"
    path: $(MAVEN_CACHE_FOLDER)
  displayName: 'Cache Maven packages'
  continueOnError: true

# PASO 1: Validar y crear Test Cases ANTES de ejecutar tests
- task: PowerShell@2
  inputs:
    targetType: 'inline'
    script: |
      # Configuraci√≥n
      $orgUrl = "https://dev.azure.com/$(AZURE_DEVOPS_ORG)"
      $project = "$(AZURE_DEVOPS_PROJECT)"
      $testPlanId = $(TEST_PLAN_ID)
      $testSuiteId = $(TEST_SUITE_ID)
      $pat = "$(System.AccessToken)"

      # Convertir PAT a Base64
      $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$($pat)"))
      $headers = @{
          "Authorization" = "Basic $base64AuthInfo"
          "Content-Type" = "application/json"
      }

      Write-Host "========================================"
      Write-Host "PASO 1: Validaci√≥n y Auto-Creaci√≥n de Test Cases"
      Write-Host "========================================"

      # Leer el feature file
      $featureFile = "$(Build.SourcesDirectory)/src/test/java/examples/users/TC12345_ValidarLogin.feature"
      $featureContent = Get-Content $featureFile -Raw

      # Funci√≥n para verificar si un Test Case existe
      function Test-TestCaseExists {
          param($testCaseId)
          $testCaseUrl = "$orgUrl/$project/_apis/wit/workitems/$testCaseId`?api-version=7.0"
          try {
              $testCase = Invoke-RestMethod -Uri $testCaseUrl -Method Get -Headers $headers -ErrorAction Stop
              return $true
          } catch {
              return $false
          }
      }

      # Funci√≥n para crear Test Case
      function Create-TestCase {
          param($scenarioName, $type, $steps)

          Write-Host "    Creando Test Case en Azure DevOps..."

          $title = $scenarioName
          $stepsHtml = "<steps id='0' last='$($steps.Count)'>"
          $stepId = 1
          foreach ($step in $steps) {
              $stepsHtml += "<step id='$stepId' type='ValidateStep'>"
              $stepsHtml += "<parameterizedString isformatted='true'>$($step.action)</parameterizedString>"
              $stepsHtml += "<parameterizedString isformatted='true'>$($step.expected)</parameterizedString>"
              $stepsHtml += "<description/></step>"
              $stepId++
          }
          $stepsHtml += "</steps>"

          $createBody = @(
              @{ op = "add"; path = "/fields/System.Title"; value = $title },
              @{ op = "add"; path = "/fields/System.AreaPath"; value = $project },
              @{ op = "add"; path = "/fields/System.IterationPath"; value = $project },
              @{ op = "add"; path = "/fields/Microsoft.VSTS.TCM.Steps"; value = $stepsHtml },
              @{ op = "add"; path = "/fields/System.Tags"; value = if ($type) { "Automated; $type" } else { "Automated" } }
          ) | ConvertTo-Json -Depth 10

          $createUrl = "$orgUrl/$project/_apis/wit/workitems/`$Test Case?api-version=7.0"
          $headersWithContentType = $headers.Clone()
          $headersWithContentType["Content-Type"] = "application/json-patch+json"

          try {
              $newTestCase = Invoke-RestMethod -Uri $createUrl -Method Post -Headers $headersWithContentType -Body $createBody
              Write-Host "    ‚úì Test Case creado con ID: $($newTestCase.id)"
              return $newTestCase.id
          } catch {
              Write-Host "    ‚úó Error al crear Test Case: $($_.Exception.Message)"
              return $null
          }
      }

      # Funci√≥n para agregar Test Case a Test Suite
      function Add-TestCaseToSuite {
          param($testCaseId, $suiteId)

          Write-Host "    Agregando TC$testCaseId al Test Suite $suiteId..."

          $addUrl = "$orgUrl/$project/_apis/testplan/Plans/$testPlanId/Suites/$suiteId/TestCase/$testCaseId`?api-version=7.1-preview.3"

          try {
              Invoke-RestMethod -Uri $addUrl -Method Post -Headers $headers -ContentType "application/json" | Out-Null
              Write-Host "    ‚úì Test Case agregado al Suite"
              return $true
          } catch {
              Write-Host "    ‚ö† Error al agregar al Suite: $($_.Exception.Message)"
              return $false
          }
      }

      # Funci√≥n para extraer steps del Gherkin
      function Get-StepsFromScenario {
          param($content, $lineNumber)

          $steps = @()
          $lines = $content -split "`n"

          for ($i = $lineNumber; $i -lt $lines.Count; $i++) {
              $line = $lines[$i].Trim()

              if ($line -match "^(Given|When|Then|And)\s+(.+)") {
                  $action = $line
                  $expected = if ($Matches[1] -eq "Then") { "Verificar resultado" } else { "Ejecutar paso" }
                  $steps += @{ action = $action; expected = $expected }
              }

              if ($line -match "^Examples:") { break }
          }

          return $steps
      }

      # Funci√≥n para actualizar feature file
      function Update-FeatureFileWithId {
          param($featureFilePath, $oldPattern, $newId, $scenarioName)

          $content = Get-Content $featureFilePath -Raw

          if ($oldPattern -eq "NEW" -or $oldPattern -eq "AUTO") {
              $pattern = "@TestCase=$oldPattern"
              # Agregar prefijo TCX_ si no existe
              if ($scenarioName -notmatch "^TC\d+_") {
                  $replacement = "@TestCase=$newId`n@Type=`$1`n@Offline`nScenario Outline: TC$newId`_$scenarioName"
                  $content = $content -replace "(@TestCase=$oldPattern\s+@Type=(\w+)\s+@Offline\s+Scenario Outline:\s+$([regex]::Escape($scenarioName)))", $replacement
              } else {
                  $replacement = "@TestCase=$newId"
                  $content = $content -replace $pattern, $replacement
              }
          }

          Set-Content -Path $featureFilePath -Value $content -NoNewline
          return $true
      }

      # Escanear feature file
      Write-Host "`nValidando Test Cases en feature file..."
      $lines = $featureContent -split "`n"
      $scenariosToCreate = @()
      $existingTestCases = @()
      $createdTestCases = @()

      for ($i = 0; $i -lt $lines.Count; $i++) {
          $line = $lines[$i].Trim()

          if ($line -match "@TestCase=(.+)") {
              $testCaseId = $Matches[1].Trim()
              $lineNumber = $i

              # Buscar @Type
              $type = $null
              for ($j = [Math]::Max(0, $i-3); $j -lt [Math]::Min($lines.Count, $i+3); $j++) {
                  if ($lines[$j] -match "@Type=(\w+)") {
                      $type = $Matches[1]
                      break
                  }
              }

              # Buscar nombre del Scenario
              $scenarioName = ""
              for ($k = $i+1; $k -lt [Math]::Min($lines.Count, $i+5); $k++) {
                  if ($lines[$k] -match "Scenario Outline:\s*(.+)") {
                      $scenarioName = $Matches[1].Trim()
                      break
                  }
              }

              # Verificar si es ID num√©rico o marcador
              if ($testCaseId -match '^\d+$') {
                  Write-Host "`n  Validando TC$testCaseId..."
                  $exists = Test-TestCaseExists -testCaseId $testCaseId
                  if ($exists) {
                      Write-Host "    ‚úì Existe en Test Plan"
                      $existingTestCases += [int]$testCaseId
                  } else {
                      Write-Host "    ‚úó NO existe en Test Plan - ERROR"
                      exit 1
                  }
              } elseif ($testCaseId -eq "NEW" -or $testCaseId -eq "AUTO") {
                  Write-Host "`n  Detectado nuevo Test Case: $scenarioName"
                  $steps = Get-StepsFromScenario -content $featureContent -lineNumber $lineNumber
                  $scenariosToCreate += @{
                      oldPattern = $testCaseId
                      scenarioName = $scenarioName
                      type = $type
                      steps = $steps
                  }
              }
          }
      }

      # Crear Test Cases nuevos
      if ($scenariosToCreate.Count -gt 0) {
          Write-Host "`n========================================"
          Write-Host "Creando $($scenariosToCreate.Count) Test Case(s) nuevo(s)..."
          Write-Host "========================================"

          foreach ($scenario in $scenariosToCreate) {
              Write-Host "`n  Scenario: $($scenario.scenarioName)"
              Write-Host "  Type: $(if($scenario.type){$scenario.type}else{'Gen√©rico'})"

              # Crear Test Case
              $newId = Create-TestCase -scenarioName $scenario.scenarioName `
                                       -type $scenario.type `
                                       -steps $scenario.steps

              if ($newId) {
                  # Agregar a Test Suite
                  $added = Add-TestCaseToSuite -testCaseId $newId -suiteId $testSuiteId

                  if ($added) {
                      # Actualizar feature file
                      $updated = Update-FeatureFileWithId -featureFilePath $featureFile `
                                                          -oldPattern $scenario.oldPattern `
                                                          -newId $newId `
                                                          -scenarioName $scenario.scenarioName

                      if ($updated) {
                          Write-Host "    ‚úì Feature file actualizado localmente"
                          $createdTestCases += $newId
                      }
                  }
              }
          }

          # Guardar IDs creados para el segundo step
          $createdIdsJson = $createdTestCases | ConvertTo-Json
          Set-Content -Path "$(Build.SourcesDirectory)/created_test_cases.json" -Value $createdIdsJson

          Write-Host "`n‚úì Test Cases creados: $($createdTestCases -join ', ')"
      } else {
          Write-Host "`n‚úì Todos los Test Cases ya existen en Test Plan"
          Set-Content -Path "$(Build.SourcesDirectory)/created_test_cases.json" -Value "[]"
      }

      Write-Host "`n========================================"
      Write-Host "Continuando con ejecuci√≥n de tests..."
      Write-Host "========================================`n"
  displayName: 'Validate and Auto-Create Test Cases'
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)

- task: Maven@4
  inputs:
    mavenPomFile: 'pom.xml'
    goals: 'clean test'
    options: '-Dkarate.env=qa'
    publishJUnitResults: false  # Desactivamos para publicar manualmente despu√©s
    javaHomeOption: 'JDKVersion'
    jdkVersionOption: '1.17'
    mavenVersionOption: 'Default'
  displayName: 'Run Karate Tests'
  continueOnError: true  # Continuar aunque los tests fallen

- script: |
    echo "========================================="
    echo "Verificando archivos generados..."
    echo "========================================="
    echo ""
    echo "Contenido de target/surefire-reports:"
    ls -la $(Build.SourcesDirectory)/target/surefire-reports/ || echo "Directory not found"
    echo ""
    echo "Archivos XML encontrados:"
    find $(Build.SourcesDirectory)/target -name "*.xml" -type f || echo "No XML files found"
    echo ""
    echo "Estructura completa de target:"
    ls -R $(Build.SourcesDirectory)/target/
  displayName: 'List Target Directory Contents'

# Script para asociar resultados con Azure Test Plan (con iteraciones)
- task: PowerShell@2
  condition: always()
  inputs:
    targetType: 'inline'
    script: |
      # Configuraci√≥n
      $orgUrl = "https://dev.azure.com/$(AZURE_DEVOPS_ORG)"
      $project = "$(AZURE_DEVOPS_PROJECT)"
      $testPlanId = $(TEST_PLAN_ID)
      $testSuiteId = $(TEST_SUITE_ID)
      $pat = "$(System.AccessToken)"

      # Convertir PAT a Base64
      $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$($pat)"))
      $headers = @{
          "Authorization" = "Basic $base64AuthInfo"
          "Content-Type" = "application/json"
      }

      Write-Host "========================================"
      Write-Host "Creando Test Run para Test Plan $testPlanId..."
      Write-Host "========================================"

      # Crear Test Run con configuraci√≥n
      $testRunBody = @{
          name = "Karate Automated Run - Build $(Build.BuildNumber)"
          plan = @{ id = $testPlanId }
          automated = $true
          build = @{ id = "$(Build.BuildId)" }
          buildPlatform = "Karate"
          buildFlavor = "qa"
          configurationIds = @()  # Se puede agregar ID de configuraci√≥n si existe
          comment = "Automated test execution from Azure Pipeline"
      } | ConvertTo-Json -Depth 10

      $createRunUrl = "$orgUrl/$project/_apis/test/runs?api-version=7.0"
      $testRun = Invoke-RestMethod -Uri $createRunUrl -Method Post -Headers $headers -Body $testRunBody
      $testRunId = $testRun.id
      Write-Host "‚úì Test Run creado con ID: $testRunId"

      # Leer el feature file para obtener los par√°metros de Examples
      Write-Host "`nExtrayendo par√°metros del feature file..."
      $featureFile = "$(Build.SourcesDirectory)/src/test/java/examples/users/TC12345_ValidarLogin.feature"
      $featureContent = Get-Content $featureFile -Raw

      # Parsear los par√°metros de cada Test Case del feature file
      $testDataMap = @{}
      $testMetadataMap = @{}  # Para almacenar @Type y otros metadatos

      # Funci√≥n para descubrir todos los Test Cases en el feature file
      function Get-AllTestCases {
          param($content)

          $testCases = @()
          $lines = $content -split "`n"

          for ($i = 0; $i -lt $lines.Count; $i++) {
              $line = $lines[$i].Trim()
              if ($line -match "@TestCase=(\d+)") {
                  $tcId = [int]$Matches[1]

                  # Buscar @Type (opcional) en l√≠neas cercanas
                  $type = $null
                  for ($j = [Math]::Max(0, $i-5); $j -lt [Math]::Min($lines.Count, $i+5); $j++) {
                      if ($lines[$j] -match "@Type=(\w+)") {
                          $type = $Matches[1]
                          break
                      }
                  }

                  # Buscar nombre del Scenario
                  $scenarioName = ""
                  if ($i+1 -lt $lines.Count -and $lines[$i+1] -match "Scenario Outline:\s*(.+)") {
                      $scenarioName = $Matches[1].Trim()
                  }

                  $testCases += @{
                      id = $tcId
                      type = $type
                      scenarioName = $scenarioName
                  }
              }
          }

          return $testCases
      }

      # Funci√≥n para extraer datos de Examples de un Scenario Outline
      function Parse-ExamplesTable {
          param($content, $testCaseId)

          $rows = @()
          $lines = $content -split "`n"
          $inExamples = $false
          $inCorrectTestCase = $false
          $columns = @()

          for ($i = 0; $i -lt $lines.Count; $i++) {
              $line = $lines[$i].Trim()

              # Verificar si estamos en el Test Case correcto
              if ($line -match "@TestCase=$testCaseId") {
                  $inCorrectTestCase = $true
              }
              # Si encontramos otro @TestCase, salir
              elseif ($line -match "@TestCase=" -and $inCorrectTestCase) {
                  break
              }

              # Si estamos en el Test Case correcto y encontramos Examples:
              if ($inCorrectTestCase -and $line -match "^Examples:") {
                  $inExamples = $true
                  continue
              }

              # Si estamos en Examples, procesar las l√≠neas con |
              if ($inExamples -and $line -match '\|') {
                  $parts = $line -split '\|' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }

                  if ($parts.Count -gt 0) {
                      # Primera l√≠nea con | son los headers
                      if ($columns.Count -eq 0) {
                          $columns = $parts
                      }
                      # Las siguientes l√≠neas son datos
                      else {
                          $row = @{}
                          for ($j = 0; $j -lt [Math]::Min($columns.Count, $parts.Count); $j++) {
                              $row[$columns[$j]] = $parts[$j]
                          }
                          $rows += $row
                      }
                  }
              }
          }

          return @{
              rows = $rows
              columns = $columns
          }
      }

      # Descubrir autom√°ticamente todos los Test Cases
      Write-Host "`n  Descubriendo Test Cases en el feature file..."
      $allTestCases = Get-AllTestCases -content $featureContent
      Write-Host "  ‚úì Test Cases encontrados: $($allTestCases.Count)"

      # Extraer par√°metros para cada Test Case descubierto
      foreach ($tc in $allTestCases) {
          Write-Host "`n  Extrayendo TC$($tc.id)..."
          if ($tc.type) {
              Write-Host "    @Type: $($tc.type)"
          }
          Write-Host "    Scenario: $($tc.scenarioName)"

          $result = Parse-ExamplesTable -content $featureContent -testCaseId $tc.id
          $testDataMap[$tc.id] = $result.rows
          $testMetadataMap[$tc.id] = @{
              type = $tc.type
              scenarioName = $tc.scenarioName
              columns = $result.columns
          }

          Write-Host "    Columnas: $($result.columns -join ', ')"
          Write-Host "    Filas: $($result.rows.Count)"
      }

      Write-Host "`n  RESUMEN:"
      foreach ($tc in $allTestCases) {
          Write-Host "  TC$($tc.id): $($testDataMap[$tc.id].Count) ejemplos | Tipo: $(if($tc.type){$tc.type}else{'Gen√©rico'})"
      }

      # Funci√≥n para generar comentarios din√°micos
      function Create-TestComment {
          param($testCaseId, $iterationNumber, $totalIterations, $testData, $outcome, $duration, $metadata)

          $statusIcon = if ($outcome -eq "Passed") { "‚úì" } else { "‚úó" }
          $type = $metadata.type
          $scenarioName = $metadata.scenarioName

          # Determinar t√≠tulo del test basado en @Type o nombre del scenario
          $testTitle = if ($type) {
              switch ($type) {
                  "LoginSuccess" { "Login exitoso" }
                  "LoginFailed" { "Login fallido esperado" }
                  "CreateUser" { "Usuario creado" }
                  "UpdateUser" { "Usuario actualizado" }
                  "DeleteUser" { "Usuario eliminado" }
                  default { $scenarioName }
              }
          } else {
              # Usar nombre del scenario sin el prefijo TCX_
              $scenarioName -replace "^TC\d+_", ""
          }

          # Crear comentario base
          $comment = "$statusIcon TC$testCaseId - Iteraci√≥n $iterationNumber/$totalIterations`: $testTitle`n"

          # Agregar par√°metros din√°micamente
          if ($testData) {
              $comment += "Par√°metros:`n"
              foreach ($key in $testData.Keys | Sort-Object) {
                  $value = $testData[$key]
                  # Ocultar passwords parcialmente
                  if ($key -eq "password") {
                      $value = "********"
                  }
                  $comment += "  ‚Ä¢ $key`: $value`n"
              }
          }

          # Agregar duraci√≥n
          $comment += "Duraci√≥n: $($duration)ms"

          return $comment
      }

      # Leer resultados de Karate (archivo XML de surefire)
      $xmlFiles = Get-ChildItem -Path "$(Build.SourcesDirectory)/target/surefire-reports" -Filter "TEST-*.xml" -Recurse

      # Array para almacenar TODAS las iteraciones (sin consolidar)
      $allIterations = @()

      foreach ($xmlFile in $xmlFiles) {
          Write-Host "`nProcesando archivo: $($xmlFile.Name)"
          [xml]$xml = Get-Content $xmlFile.FullName

          $iterationCounter = @{}

          foreach ($testcase in $xml.testsuite.testcase) {
              $testName = $testcase.name
              $className = $testcase.classname

              # Extraer el TestCase ID del nombre del test
              if ($testName -match 'TC(\d+)_(.+?)\s') {
                  $testCaseId = [int]$Matches[1]  # Convertir a int
                  $testCaseTitle = "TC$($testCaseId)_" + $Matches[2].Trim()

                  # Contador de iteraciones por Test Case
                  if (-not $iterationCounter.ContainsKey($testCaseId)) {
                      $iterationCounter[$testCaseId] = 0
                  }
                  $iterationCounter[$testCaseId]++
                  $iterationNumber = $iterationCounter[$testCaseId]

                  $outcome = "Passed"
                  $errorMessage = ""
                  $stackTrace = ""

                  if ($testcase.failure) {
                      $outcome = "Failed"
                      $errorMessage = $testcase.failure.message
                      $stackTrace = $testcase.failure.'#text'
                  } elseif ($testcase.error) {
                      $outcome = "Failed"
                      $errorMessage = $testcase.error.message
                      $stackTrace = $testcase.error.'#text'
                  }

                  # Convertir duration de forma segura
                  $timeValue = $testcase.time
                  if ($timeValue -is [string]) {
                      $duration = [int]([double]::Parse($timeValue, [System.Globalization.CultureInfo]::InvariantCulture) * 1000)
                  } else {
                      $duration = [int]([double]$timeValue * 1000)
                  }

                  # Obtener par√°metros de la tabla Examples y generar comentario din√°mico
                  $testData = $null
                  $iterationParams = ""
                  $detailedComment = ""

                  if ($testDataMap.ContainsKey($testCaseId) -and $testDataMap[$testCaseId].Count -ge $iterationNumber) {
                      $testData = $testDataMap[$testCaseId][$iterationNumber - 1]
                      $totalIterations = $testDataMap[$testCaseId].Count
                      $metadata = $testMetadataMap[$testCaseId]

                      # Generar comentario usando la funci√≥n din√°mica
                      $detailedComment = Create-TestComment -testCaseId $testCaseId `
                                                           -iterationNumber $iterationNumber `
                                                           -totalIterations $totalIterations `
                                                           -testData $testData `
                                                           -outcome $outcome `
                                                           -duration $duration `
                                                           -metadata $metadata

                      # Crear descripci√≥n corta para iterationParams (usar primer par√°metro relevante)
                      $firstKey = ($testData.Keys | Where-Object { $_ -ne 'expectedStatus' -and $_ -ne 'timeout' } | Select-Object -First 1)
                      if ($firstKey) {
                          $iterationParams = "$firstKey`: $($testData[$firstKey])"
                      } else {
                          $iterationParams = "Iteration $iterationNumber"
                      }
                  } else {
                      $iterationParams = "Iteration $iterationNumber"
                      $detailedComment = "Iteration $iterationNumber - $outcome"
                  }

                  Write-Host "  [$iterationNumber] Test Case $testCaseId - $outcome ($duration ms) - $iterationParams"

                  # Agregar cada iteraci√≥n como un resultado separado
                  $allIterations += @{
                      testCaseId = $testCaseId
                      testCaseTitle = $testCaseTitle
                      iterationNumber = $iterationNumber
                      iterationParams = $iterationParams
                      detailedComment = $detailedComment
                      outcome = $outcome
                      errorMessage = $errorMessage
                      stackTrace = $stackTrace
                      duration = $duration
                      automatedTestName = "$testCaseTitle - Iteration $iterationNumber"
                  }
              }
          }
      }

      Write-Host "`n========================================"
      Write-Host "Total de iteraciones encontradas: $($allIterations.Count)"

      # Agrupar por Test Case para mostrar resumen
      $summary = $allIterations | Group-Object -Property testCaseId
      foreach ($group in $summary) {
          $passed = ($group.Group | Where-Object { $_.outcome -eq "Passed" }).Count
          $failed = ($group.Group | Where-Object { $_.outcome -eq "Failed" }).Count
          Write-Host "  Test Case $($group.Name): $($group.Count) iteraciones ($passed passed, $failed failed)"
      }
      Write-Host "========================================"

      # Obtener Test Points para el Test Suite (incluir workItemProperties para obtener revision)
      $testPointsUrl = "$orgUrl/$project/_apis/test/plans/$testPlanId/suites/$testSuiteId/points?includePointDetails=true&api-version=7.0"
      $testPoints = Invoke-RestMethod -Uri $testPointsUrl -Method Get -Headers $headers
      Write-Host "`n‚úì Test Points obtenidos: $($testPoints.count)"

      # Crear array de resultados para publicar (UNA entrada por CADA iteraci√≥n)
      $resultsToPublish = @()

      foreach ($iteration in $allIterations) {
          # Buscar el Test Point correspondiente
          $testPoint = $testPoints.value | Where-Object {
              $_.testCase.id -eq $iteration.testCaseId
          } | Select-Object -First 1

          if ($testPoint) {
              # Obtener informaci√≥n del Test Case desde el Test Point
              $testCaseRef = $testPoint.testCase

              # Obtener detalles completos del Test Case para revision
              $testCaseUrl = "$orgUrl/$project/_apis/wit/workitems/$($iteration.testCaseId)?api-version=7.0"
              try {
                  $testCaseDetails = Invoke-RestMethod -Uri $testCaseUrl -Method Get -Headers $headers
                  $testCaseRevision = $testCaseDetails.rev
              } catch {
                  Write-Host "‚ö† No se pudo obtener revision para Test Case $($iteration.testCaseId), usando 1 por defecto"
                  $testCaseRevision = 1
              }

              # Crear resultado con informaci√≥n de iteraci√≥n (incluyendo campos requeridos por Azure DevOps)
              $resultData = @{
                  testCase = @{
                      id = [string]$iteration.testCaseId  # Debe ser string seg√∫n API
                  }
                  testCaseTitle = $iteration.testCaseTitle
                  testCaseRevision = $testCaseRevision  # Campo requerido
                  testPoint = @{ id = [string]$testPoint.id }  # Debe ser string
                  outcome = $iteration.outcome
                  state = "Completed"
                  durationInMs = $iteration.duration
                  automatedTestName = $iteration.automatedTestName
                  comment = $iteration.detailedComment  # Comentario detallado con par√°metros del test
                  # Campos adicionales para mostrar en Test Results
                  priority = if ($testPoint.priority) { $testPoint.priority } else { 2 }  # Priority por defecto: 2
                  owner = if ($testPoint.assignedTo) { $testPoint.assignedTo } else { $null }
                  configuration = @{ name = "qa" }  # Configuraci√≥n del ambiente
                  iterationDetails = @( @{
                      id = $iteration.iterationNumber
                      outcome = $iteration.outcome
                      duration = $iteration.duration
                  } )
              }

              # Agregar mensaje de error si existe
              if ($iteration.errorMessage) {
                  $resultData.errorMessage = $iteration.errorMessage
              }

              # Agregar stack trace si existe
              if ($iteration.stackTrace) {
                  $resultData.stackTrace = $iteration.stackTrace
              }

              $resultsToPublish += $resultData
          } else {
              Write-Host "‚ö† WARNING: No se encontr√≥ Test Point para Test Case ID: $($iteration.testCaseId)"
          }
      }

      if ($resultsToPublish.Count -gt 0) {
          Write-Host "`n========================================"
          Write-Host "Publicando $($resultsToPublish.Count) resultados al Test Run..."
          Write-Host "========================================"

          # Azure DevOps tiene un l√≠mite de ~200 resultados por request
          # Dividir en lotes si es necesario
          $batchSize = 100
          $totalBatches = [Math]::Ceiling($resultsToPublish.Count / $batchSize)

          for ($i = 0; $i -lt $totalBatches; $i++) {
              $start = $i * $batchSize
              $end = [Math]::Min(($i + 1) * $batchSize, $resultsToPublish.Count)
              $batch = $resultsToPublish[$start..($end-1)]

              Write-Host "  Publicando lote $($i+1)/$totalBatches ($($batch.Count) resultados)..."

              $publishBody = $batch | ConvertTo-Json -Depth 10
              $publishUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/results?api-version=7.0"

              try {
                  # Debug: Mostrar el primer resultado para verificar formato
                  if ($i -eq 0) {
                      Write-Host "  Sample result (first item):"
                      Write-Host ($batch[0] | ConvertTo-Json -Depth 5)
                  }

                  $publishedResults = Invoke-RestMethod -Uri $publishUrl -Method Post -Headers $headers -Body $publishBody
                  Write-Host "  ‚úì Lote $($i+1) publicado exitosamente"
              } catch {
                  Write-Host "  ‚úó Error al publicar lote $($i+1): $($_.Exception.Message)"
                  Write-Host "  Response: $($_.Exception.Response)"
                  if ($_.ErrorDetails.Message) {
                      Write-Host "  Error Details: $($_.ErrorDetails.Message)"
                  }
              }
          }

          Write-Host "`n‚úì Todos los resultados publicados"

          # Adjuntar reportes de Karate al Test Run (en formato ZIP)
          Write-Host "`n========================================"
          Write-Host "Creando y adjuntando reportes de Karate al Test Run..."
          Write-Host "========================================"

          $targetPath = "$(Build.SourcesDirectory)/target"
          $tempZipPath = "$(Build.SourcesDirectory)/temp-zips"

          # Crear directorio temporal para ZIPs
          New-Item -ItemType Directory -Force -Path $tempZipPath | Out-Null

          # 1. Comprimir karate.log
          $karateLogPath = Join-Path $targetPath "karate.log"
          if (Test-Path $karateLogPath) {
              try {
                  $karateLogZip = Join-Path $tempZipPath "karate-log.zip"
                  Compress-Archive -Path $karateLogPath -DestinationPath $karateLogZip -Force
                  Write-Host "  ‚úì Creado: karate-log.zip"

                  # Adjuntar al Test Run
                  $fileContent = [System.IO.File]::ReadAllBytes($karateLogZip)
                  $base64Content = [System.Convert]::ToBase64String($fileContent)
                  $attachmentBody = @{
                      stream = $base64Content
                      fileName = "karate-log.zip"
                      comment = "Karate Execution Log"
                      attachmentType = "GeneralAttachment"
                  } | ConvertTo-Json
                  $attachmentUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/attachments?api-version=7.0"
                  Invoke-RestMethod -Uri $attachmentUrl -Method Post -Headers $headers -Body $attachmentBody | Out-Null
                  Write-Host "  ‚úì Adjuntado: karate-log.zip al Test Run"
              } catch {
                  Write-Host "  ‚ö† Error con karate-log.zip: $($_.Exception.Message)"
              }
          } else {
              Write-Host "  ‚ö† No se encontr√≥: karate.log"
          }

          # 2. Comprimir cucumber-reports/
          $cucumberReportsPath = Join-Path $targetPath "cucumber-reports"
          if (Test-Path $cucumberReportsPath) {
              try {
                  $cucumberReportsZip = Join-Path $tempZipPath "cucumber-reports.zip"
                  Compress-Archive -Path "$cucumberReportsPath/*" -DestinationPath $cucumberReportsZip -Force
                  Write-Host "  ‚úì Creado: cucumber-reports.zip"

                  # Adjuntar al Test Run
                  $fileContent = [System.IO.File]::ReadAllBytes($cucumberReportsZip)
                  $base64Content = [System.Convert]::ToBase64String($fileContent)
                  $attachmentBody = @{
                      stream = $base64Content
                      fileName = "cucumber-reports.zip"
                      comment = "Karate HTML Reports"
                      attachmentType = "GeneralAttachment"
                  } | ConvertTo-Json
                  $attachmentUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/attachments?api-version=7.0"
                  Invoke-RestMethod -Uri $attachmentUrl -Method Post -Headers $headers -Body $attachmentBody | Out-Null
                  Write-Host "  ‚úì Adjuntado: cucumber-reports.zip al Test Run"
              } catch {
                  Write-Host "  ‚ö† Error con cucumber-reports.zip: $($_.Exception.Message)"
              }
          } else {
              Write-Host "  ‚ö† No se encontr√≥: cucumber-reports/"
          }

          # Limpiar directorio temporal
          Remove-Item -Path $tempZipPath -Recurse -Force -ErrorAction SilentlyContinue

          Write-Host "`n‚úì Reportes comprimidos y adjuntados al Test Run"

          # Completar el Test Run
          Write-Host "`nCompletando Test Run $testRunId..."
          $updateRunBody = @{
              state = "Completed"
          } | ConvertTo-Json

          $updateRunUrl = "$orgUrl/$project/_apis/test/runs/$($testRunId)?api-version=7.0"
          Write-Host "URL: $updateRunUrl"

          try {
              Invoke-RestMethod -Uri $updateRunUrl -Method Patch -Headers $headers -Body $updateRunBody
              Write-Host "‚úì Test Run $testRunId completado"
          } catch {
              Write-Host "‚ö† Error al completar Test Run: $($_.Exception.Message)"
          }

          # ========================================
          # PASO 2: Git Push (si hubo Test Cases creados)
          # ========================================
          $createdIdsFile = "$(Build.SourcesDirectory)/created_test_cases.json"
          if (Test-Path $createdIdsFile) {
              $createdIdsJson = Get-Content $createdIdsFile -Raw
              $createdTestCases = $createdIdsJson | ConvertFrom-Json

              if ($createdTestCases -and $createdTestCases.Count -gt 0) {
                  Write-Host "`n========================================"
                  Write-Host "Guardando cambios en Git..."
                  Write-Host "========================================"

                  $repoPath = "$(Build.SourcesDirectory)"
                  Set-Location $repoPath

                  # Configurar Git
                  git config user.email "azurepipeline@automated.com"
                  git config user.name "Azure Pipeline Bot"

                  # Agregar cambios
                  git add $featureFile

                  # Crear commit
                  $commitMessage = "Auto: Agregar IDs de Test Cases [$($createdTestCases -join ', ')]`n`n" +
                                  "Test Cases creados autom√°ticamente:`n"
                  foreach ($id in $createdTestCases) {
                      $commitMessage += "- TC$id`n"
                  }
                  $commitMessage += "`nü§ñ Generado autom√°ticamente por Azure Pipeline"

                  git commit -m $commitMessage

                  # Configurar remote con GitHub PAT para push
                  Write-Host "`n  Configurando credenciales de GitHub..."
                  $githubPat = $env:GITHUB_PAT
                  if ([string]::IsNullOrEmpty($githubPat)) {
                      Write-Host "  ‚úó ERROR: Variable GITHUB_PAT no configurada"
                      Write-Host "  Por favor configura el GitHub Personal Access Token en Pipeline Variables"
                  } else {
                      # Obtener la URL actual del repositorio
                      $currentRemote = git config --get remote.origin.url
                      Write-Host "  Remote actual: $currentRemote"

                      # Construir nueva URL con token
                      if ($currentRemote -match "github\.com[:/](.+)/(.+?)(\.git)?$") {
                          $repoOwner = $Matches[1]
                          $repoName = $Matches[2]
                          $authenticatedUrl = "https://$githubPat@github.com/$repoOwner/$repoName.git"

                          Write-Host "  Repository: $repoOwner/$repoName"

                          # Actualizar remote temporalmente
                          git remote set-url origin $authenticatedUrl

                          # Push
                          Write-Host "`n  Pushing cambios al repositorio..."
                          try {
                              git push origin HEAD:main
                              Write-Host "`n‚úì Cambios guardados y pusheados exitosamente"
                              Write-Host "  Test Cases creados: $($createdTestCases -join ', ')"
                          } catch {
                              Write-Host "`n‚úó Error al hacer push: $($_.Exception.Message)"
                          } finally {
                              # Restaurar URL original (sin token) por seguridad
                              git remote set-url origin $currentRemote
                          }
                      } else {
                          Write-Host "  ‚úó ERROR: No se pudo parsear la URL del repositorio"
                          Write-Host "  URL recibida: $currentRemote"
                      }
                  }
              }
          }

          Write-Host "`n========================================"
          Write-Host "RESUMEN FINAL:"
          Write-Host "========================================"
          Write-Host "Test Run ID: $testRunId"
          Write-Host "Total Iteraciones: $($allIterations.Count)"
          Write-Host "URL: $orgUrl/$project/_testManagement/runs?runId=$testRunId&_a=resultSummary"
          Write-Host "========================================"
      } else {
          Write-Host "‚úó ERROR: No se encontraron resultados para publicar"
          exit 1
      }
  displayName: 'Associate Test Results with Azure Test Plan'
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    GITHUB_PAT: $(GITHUB_PAT)

- task: PublishBuildArtifacts@1
  condition: always()
  inputs:
    PathtoPublish: '$(Build.SourcesDirectory)/target'
    ArtifactName: 'test-reports'
    publishLocation: 'Container'
  displayName: 'Publish All Test Reports'
