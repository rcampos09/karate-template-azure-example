trigger:
  - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  MAVEN_CACHE_FOLDER: $(Pipeline.Workspace)/.m2/repository
  MAVEN_OPTS: '-Dmaven.repo.local=$(MAVEN_CACHE_FOLDER)'
  # IDs de tu Azure DevOps
  AZURE_DEVOPS_ORG: 'dontester'
  AZURE_DEVOPS_PROJECT: 'Automated Test Plan'
  TEST_PLAN_ID: 6
  TEST_SUITE_ID: 8

steps:
- task: JavaToolInstaller@0
  inputs:
    versionSpec: '17'
    jdkArchitectureOption: 'x64'
    jdkSourceOption: 'PreInstalled'
  displayName: 'Set up JDK 17'

- script: |
    mkdir -p $(MAVEN_CACHE_FOLDER)
  displayName: 'Create Maven cache directory'

- task: Cache@2
  inputs:
    key: 'maven | "$(Agent.OS)" | **/pom.xml'
    restoreKeys: |
      maven | "$(Agent.OS)"
    path: $(MAVEN_CACHE_FOLDER)
  displayName: 'Cache Maven packages'
  continueOnError: true

- task: Maven@4
  inputs:
    mavenPomFile: 'pom.xml'
    goals: 'clean test'
    options: '-Dkarate.env=qa'
    publishJUnitResults: false  # Desactivamos para publicar manualmente después
    javaHomeOption: 'JDKVersion'
    jdkVersionOption: '1.17'
    mavenVersionOption: 'Default'
  displayName: 'Run Karate Tests'
  continueOnError: true  # Continuar aunque los tests fallen

- script: |
    echo "========================================="
    echo "Verificando archivos generados..."
    echo "========================================="
    echo ""
    echo "Contenido de target/surefire-reports:"
    ls -la $(Build.SourcesDirectory)/target/surefire-reports/ || echo "Directory not found"
    echo ""
    echo "Archivos XML encontrados:"
    find $(Build.SourcesDirectory)/target -name "*.xml" -type f || echo "No XML files found"
    echo ""
    echo "Estructura completa de target:"
    ls -R $(Build.SourcesDirectory)/target/
  displayName: 'List Target Directory Contents'

# Script para asociar resultados con Azure Test Plan (con iteraciones)
- task: PowerShell@2
  condition: always()
  inputs:
    targetType: 'inline'
    script: |
      # Configuración
      $orgUrl = "https://dev.azure.com/$(AZURE_DEVOPS_ORG)"
      $project = "$(AZURE_DEVOPS_PROJECT)"
      $testPlanId = $(TEST_PLAN_ID)
      $testSuiteId = $(TEST_SUITE_ID)
      $pat = "$(System.AccessToken)"

      # Convertir PAT a Base64
      $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$($pat)"))
      $headers = @{
          "Authorization" = "Basic $base64AuthInfo"
          "Content-Type" = "application/json"
      }

      Write-Host "========================================"
      Write-Host "Creando Test Run para Test Plan $testPlanId..."
      Write-Host "========================================"

      # Crear Test Run con configuración
      $testRunBody = @{
          name = "Karate Automated Run - Build $(Build.BuildNumber)"
          plan = @{ id = $testPlanId }
          automated = $true
          build = @{ id = "$(Build.BuildId)" }
          buildPlatform = "Karate"
          buildFlavor = "qa"
          configurationIds = @()  # Se puede agregar ID de configuración si existe
          comment = "Automated test execution from Azure Pipeline"
      } | ConvertTo-Json -Depth 10

      $createRunUrl = "$orgUrl/$project/_apis/test/runs?api-version=7.0"
      $testRun = Invoke-RestMethod -Uri $createRunUrl -Method Post -Headers $headers -Body $testRunBody
      $testRunId = $testRun.id
      Write-Host "✓ Test Run creado con ID: $testRunId"

      # Leer el feature file para obtener los parámetros de Examples
      Write-Host "`nExtrayendo parámetros del feature file..."
      $featureFile = "$(Build.SourcesDirectory)/src/test/java/examples/users/TC12345_ValidarLogin.feature"
      $featureContent = Get-Content $featureFile -Raw

      # Parsear los parámetros de cada Test Case del feature file
      $testDataMap = @{}
      $testMetadataMap = @{}  # Para almacenar @Type y otros metadatos

      # Función para descubrir todos los Test Cases en el feature file
      function Get-AllTestCases {
          param($content)

          $testCases = @()
          $lines = $content -split "`n"

          for ($i = 0; $i -lt $lines.Count; $i++) {
              $line = $lines[$i].Trim()
              if ($line -match "@TestCase=(\d+)") {
                  $tcId = [int]$Matches[1]

                  # Buscar @Type (opcional) en líneas cercanas
                  $type = $null
                  for ($j = [Math]::Max(0, $i-5); $j -lt [Math]::Min($lines.Count, $i+5); $j++) {
                      if ($lines[$j] -match "@Type=(\w+)") {
                          $type = $Matches[1]
                          break
                      }
                  }

                  # Buscar nombre del Scenario
                  $scenarioName = ""
                  if ($i+1 -lt $lines.Count -and $lines[$i+1] -match "Scenario Outline:\s*(.+)") {
                      $scenarioName = $Matches[1].Trim()
                  }

                  $testCases += @{
                      id = $tcId
                      type = $type
                      scenarioName = $scenarioName
                  }
              }
          }

          return $testCases
      }

      # Función para extraer datos de Examples de un Scenario Outline
      function Parse-ExamplesTable {
          param($content, $testCaseId)

          $rows = @()
          $lines = $content -split "`n"
          $inExamples = $false
          $inCorrectTestCase = $false
          $columns = @()

          for ($i = 0; $i -lt $lines.Count; $i++) {
              $line = $lines[$i].Trim()

              # Verificar si estamos en el Test Case correcto
              if ($line -match "@TestCase=$testCaseId") {
                  $inCorrectTestCase = $true
              }
              # Si encontramos otro @TestCase, salir
              elseif ($line -match "@TestCase=" -and $inCorrectTestCase) {
                  break
              }

              # Si estamos en el Test Case correcto y encontramos Examples:
              if ($inCorrectTestCase -and $line -match "^Examples:") {
                  $inExamples = $true
                  continue
              }

              # Si estamos en Examples, procesar las líneas con |
              if ($inExamples -and $line -match '\|') {
                  $parts = $line -split '\|' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }

                  if ($parts.Count -gt 0) {
                      # Primera línea con | son los headers
                      if ($columns.Count -eq 0) {
                          $columns = $parts
                      }
                      # Las siguientes líneas son datos
                      else {
                          $row = @{}
                          for ($j = 0; $j -lt [Math]::Min($columns.Count, $parts.Count); $j++) {
                              $row[$columns[$j]] = $parts[$j]
                          }
                          $rows += $row
                      }
                  }
              }
          }

          return @{
              rows = $rows
              columns = $columns
          }
      }

      # Descubrir automáticamente todos los Test Cases
      Write-Host "`n  Descubriendo Test Cases en el feature file..."
      $allTestCases = Get-AllTestCases -content $featureContent
      Write-Host "  ✓ Test Cases encontrados: $($allTestCases.Count)"

      # Extraer parámetros para cada Test Case descubierto
      foreach ($tc in $allTestCases) {
          Write-Host "`n  Extrayendo TC$($tc.id)..."
          if ($tc.type) {
              Write-Host "    @Type: $($tc.type)"
          }
          Write-Host "    Scenario: $($tc.scenarioName)"

          $result = Parse-ExamplesTable -content $featureContent -testCaseId $tc.id
          $testDataMap[$tc.id] = $result.rows
          $testMetadataMap[$tc.id] = @{
              type = $tc.type
              scenarioName = $tc.scenarioName
              columns = $result.columns
          }

          Write-Host "    Columnas: $($result.columns -join ', ')"
          Write-Host "    Filas: $($result.rows.Count)"
      }

      Write-Host "`n  RESUMEN:"
      foreach ($tc in $allTestCases) {
          Write-Host "  TC$($tc.id): $($testDataMap[$tc.id].Count) ejemplos | Tipo: $(if($tc.type){$tc.type}else{'Genérico'})"
      }

      # Función para generar comentarios dinámicos
      function Create-TestComment {
          param($testCaseId, $iterationNumber, $totalIterations, $testData, $outcome, $duration, $metadata)

          $statusIcon = if ($outcome -eq "Passed") { "✓" } else { "✗" }
          $type = $metadata.type
          $scenarioName = $metadata.scenarioName

          # Determinar título del test basado en @Type o nombre del scenario
          $testTitle = if ($type) {
              switch ($type) {
                  "LoginSuccess" { "Login exitoso" }
                  "LoginFailed" { "Login fallido esperado" }
                  "CreateUser" { "Usuario creado" }
                  "UpdateUser" { "Usuario actualizado" }
                  "DeleteUser" { "Usuario eliminado" }
                  default { $scenarioName }
              }
          } else {
              # Usar nombre del scenario sin el prefijo TCX_
              $scenarioName -replace "^TC\d+_", ""
          }

          # Crear comentario base
          $comment = "$statusIcon TC$testCaseId - Iteración $iterationNumber/$totalIterations`: $testTitle`n"

          # Agregar parámetros dinámicamente
          if ($testData) {
              $comment += "Parámetros:`n"
              foreach ($key in $testData.Keys | Sort-Object) {
                  $value = $testData[$key]
                  # Ocultar passwords parcialmente
                  if ($key -eq "password") {
                      $value = "********"
                  }
                  $comment += "  • $key`: $value`n"
              }
          }

          # Agregar duración
          $comment += "Duración: $($duration)ms"

          return $comment
      }

      # Leer resultados de Karate (archivo XML de surefire)
      $xmlFiles = Get-ChildItem -Path "$(Build.SourcesDirectory)/target/surefire-reports" -Filter "TEST-*.xml" -Recurse

      # Array para almacenar TODAS las iteraciones (sin consolidar)
      $allIterations = @()

      foreach ($xmlFile in $xmlFiles) {
          Write-Host "`nProcesando archivo: $($xmlFile.Name)"
          [xml]$xml = Get-Content $xmlFile.FullName

          $iterationCounter = @{}

          foreach ($testcase in $xml.testsuite.testcase) {
              $testName = $testcase.name
              $className = $testcase.classname

              # Extraer el TestCase ID del nombre del test
              if ($testName -match 'TC(\d+)_(.+?)\s') {
                  $testCaseId = [int]$Matches[1]  # Convertir a int
                  $testCaseTitle = "TC$($testCaseId)_" + $Matches[2].Trim()

                  # Contador de iteraciones por Test Case
                  if (-not $iterationCounter.ContainsKey($testCaseId)) {
                      $iterationCounter[$testCaseId] = 0
                  }
                  $iterationCounter[$testCaseId]++
                  $iterationNumber = $iterationCounter[$testCaseId]

                  $outcome = "Passed"
                  $errorMessage = ""
                  $stackTrace = ""

                  if ($testcase.failure) {
                      $outcome = "Failed"
                      $errorMessage = $testcase.failure.message
                      $stackTrace = $testcase.failure.'#text'
                  } elseif ($testcase.error) {
                      $outcome = "Failed"
                      $errorMessage = $testcase.error.message
                      $stackTrace = $testcase.error.'#text'
                  }

                  # Convertir duration de forma segura
                  $timeValue = $testcase.time
                  if ($timeValue -is [string]) {
                      $duration = [int]([double]::Parse($timeValue, [System.Globalization.CultureInfo]::InvariantCulture) * 1000)
                  } else {
                      $duration = [int]([double]$timeValue * 1000)
                  }

                  # Obtener parámetros de la tabla Examples y generar comentario dinámico
                  $testData = $null
                  $iterationParams = ""
                  $detailedComment = ""

                  if ($testDataMap.ContainsKey($testCaseId) -and $testDataMap[$testCaseId].Count -ge $iterationNumber) {
                      $testData = $testDataMap[$testCaseId][$iterationNumber - 1]
                      $totalIterations = $testDataMap[$testCaseId].Count
                      $metadata = $testMetadataMap[$testCaseId]

                      # Generar comentario usando la función dinámica
                      $detailedComment = Create-TestComment -testCaseId $testCaseId `
                                                           -iterationNumber $iterationNumber `
                                                           -totalIterations $totalIterations `
                                                           -testData $testData `
                                                           -outcome $outcome `
                                                           -duration $duration `
                                                           -metadata $metadata

                      # Crear descripción corta para iterationParams (usar primer parámetro relevante)
                      $firstKey = ($testData.Keys | Where-Object { $_ -ne 'expectedStatus' -and $_ -ne 'timeout' } | Select-Object -First 1)
                      if ($firstKey) {
                          $iterationParams = "$firstKey`: $($testData[$firstKey])"
                      } else {
                          $iterationParams = "Iteration $iterationNumber"
                      }
                  } else {
                      $iterationParams = "Iteration $iterationNumber"
                      $detailedComment = "Iteration $iterationNumber - $outcome"
                  }

                  Write-Host "  [$iterationNumber] Test Case $testCaseId - $outcome ($duration ms) - $iterationParams"

                  # Agregar cada iteración como un resultado separado
                  $allIterations += @{
                      testCaseId = $testCaseId
                      testCaseTitle = $testCaseTitle
                      iterationNumber = $iterationNumber
                      iterationParams = $iterationParams
                      detailedComment = $detailedComment
                      outcome = $outcome
                      errorMessage = $errorMessage
                      stackTrace = $stackTrace
                      duration = $duration
                      automatedTestName = "$testCaseTitle - Iteration $iterationNumber"
                  }
              }
          }
      }

      Write-Host "`n========================================"
      Write-Host "Total de iteraciones encontradas: $($allIterations.Count)"

      # Agrupar por Test Case para mostrar resumen
      $summary = $allIterations | Group-Object -Property testCaseId
      foreach ($group in $summary) {
          $passed = ($group.Group | Where-Object { $_.outcome -eq "Passed" }).Count
          $failed = ($group.Group | Where-Object { $_.outcome -eq "Failed" }).Count
          Write-Host "  Test Case $($group.Name): $($group.Count) iteraciones ($passed passed, $failed failed)"
      }
      Write-Host "========================================"

      # Obtener Test Points para el Test Suite (incluir workItemProperties para obtener revision)
      $testPointsUrl = "$orgUrl/$project/_apis/test/plans/$testPlanId/suites/$testSuiteId/points?includePointDetails=true&api-version=7.0"
      $testPoints = Invoke-RestMethod -Uri $testPointsUrl -Method Get -Headers $headers
      Write-Host "`n✓ Test Points obtenidos: $($testPoints.count)"

      # Crear array de resultados para publicar (UNA entrada por CADA iteración)
      $resultsToPublish = @()

      foreach ($iteration in $allIterations) {
          # Buscar el Test Point correspondiente
          $testPoint = $testPoints.value | Where-Object {
              $_.testCase.id -eq $iteration.testCaseId
          } | Select-Object -First 1

          if ($testPoint) {
              # Obtener información del Test Case desde el Test Point
              $testCaseRef = $testPoint.testCase

              # Obtener detalles completos del Test Case para revision
              $testCaseUrl = "$orgUrl/$project/_apis/wit/workitems/$($iteration.testCaseId)?api-version=7.0"
              try {
                  $testCaseDetails = Invoke-RestMethod -Uri $testCaseUrl -Method Get -Headers $headers
                  $testCaseRevision = $testCaseDetails.rev
              } catch {
                  Write-Host "⚠ No se pudo obtener revision para Test Case $($iteration.testCaseId), usando 1 por defecto"
                  $testCaseRevision = 1
              }

              # Crear resultado con información de iteración (incluyendo campos requeridos por Azure DevOps)
              $resultData = @{
                  testCase = @{
                      id = [string]$iteration.testCaseId  # Debe ser string según API
                  }
                  testCaseTitle = $iteration.testCaseTitle
                  testCaseRevision = $testCaseRevision  # Campo requerido
                  testPoint = @{ id = [string]$testPoint.id }  # Debe ser string
                  outcome = $iteration.outcome
                  state = "Completed"
                  durationInMs = $iteration.duration
                  automatedTestName = $iteration.automatedTestName
                  comment = $iteration.detailedComment  # Comentario detallado con parámetros del test
                  # Campos adicionales para mostrar en Test Results
                  priority = if ($testPoint.priority) { $testPoint.priority } else { 2 }  # Priority por defecto: 2
                  owner = if ($testPoint.assignedTo) { $testPoint.assignedTo } else { $null }
                  configuration = @{ name = "qa" }  # Configuración del ambiente
                  iterationDetails = @( @{
                      id = $iteration.iterationNumber
                      outcome = $iteration.outcome
                      duration = $iteration.duration
                  } )
              }

              # Agregar mensaje de error si existe
              if ($iteration.errorMessage) {
                  $resultData.errorMessage = $iteration.errorMessage
              }

              # Agregar stack trace si existe
              if ($iteration.stackTrace) {
                  $resultData.stackTrace = $iteration.stackTrace
              }

              $resultsToPublish += $resultData
          } else {
              Write-Host "⚠ WARNING: No se encontró Test Point para Test Case ID: $($iteration.testCaseId)"
          }
      }

      if ($resultsToPublish.Count -gt 0) {
          Write-Host "`n========================================"
          Write-Host "Publicando $($resultsToPublish.Count) resultados al Test Run..."
          Write-Host "========================================"

          # Azure DevOps tiene un límite de ~200 resultados por request
          # Dividir en lotes si es necesario
          $batchSize = 100
          $totalBatches = [Math]::Ceiling($resultsToPublish.Count / $batchSize)

          for ($i = 0; $i -lt $totalBatches; $i++) {
              $start = $i * $batchSize
              $end = [Math]::Min(($i + 1) * $batchSize, $resultsToPublish.Count)
              $batch = $resultsToPublish[$start..($end-1)]

              Write-Host "  Publicando lote $($i+1)/$totalBatches ($($batch.Count) resultados)..."

              $publishBody = $batch | ConvertTo-Json -Depth 10
              $publishUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/results?api-version=7.0"

              try {
                  # Debug: Mostrar el primer resultado para verificar formato
                  if ($i -eq 0) {
                      Write-Host "  Sample result (first item):"
                      Write-Host ($batch[0] | ConvertTo-Json -Depth 5)
                  }

                  $publishedResults = Invoke-RestMethod -Uri $publishUrl -Method Post -Headers $headers -Body $publishBody
                  Write-Host "  ✓ Lote $($i+1) publicado exitosamente"
              } catch {
                  Write-Host "  ✗ Error al publicar lote $($i+1): $($_.Exception.Message)"
                  Write-Host "  Response: $($_.Exception.Response)"
                  if ($_.ErrorDetails.Message) {
                      Write-Host "  Error Details: $($_.ErrorDetails.Message)"
                  }
              }
          }

          Write-Host "`n✓ Todos los resultados publicados"

          # Adjuntar reportes de Karate al Test Run (en formato ZIP)
          Write-Host "`n========================================"
          Write-Host "Creando y adjuntando reportes de Karate al Test Run..."
          Write-Host "========================================"

          $targetPath = "$(Build.SourcesDirectory)/target"
          $tempZipPath = "$(Build.SourcesDirectory)/temp-zips"

          # Crear directorio temporal para ZIPs
          New-Item -ItemType Directory -Force -Path $tempZipPath | Out-Null

          # 1. Comprimir karate.log
          $karateLogPath = Join-Path $targetPath "karate.log"
          if (Test-Path $karateLogPath) {
              try {
                  $karateLogZip = Join-Path $tempZipPath "karate-log.zip"
                  Compress-Archive -Path $karateLogPath -DestinationPath $karateLogZip -Force
                  Write-Host "  ✓ Creado: karate-log.zip"

                  # Adjuntar al Test Run
                  $fileContent = [System.IO.File]::ReadAllBytes($karateLogZip)
                  $base64Content = [System.Convert]::ToBase64String($fileContent)
                  $attachmentBody = @{
                      stream = $base64Content
                      fileName = "karate-log.zip"
                      comment = "Karate Execution Log"
                      attachmentType = "GeneralAttachment"
                  } | ConvertTo-Json
                  $attachmentUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/attachments?api-version=7.0"
                  Invoke-RestMethod -Uri $attachmentUrl -Method Post -Headers $headers -Body $attachmentBody | Out-Null
                  Write-Host "  ✓ Adjuntado: karate-log.zip al Test Run"
              } catch {
                  Write-Host "  ⚠ Error con karate-log.zip: $($_.Exception.Message)"
              }
          } else {
              Write-Host "  ⚠ No se encontró: karate.log"
          }

          # 2. Comprimir cucumber-reports/
          $cucumberReportsPath = Join-Path $targetPath "cucumber-reports"
          if (Test-Path $cucumberReportsPath) {
              try {
                  $cucumberReportsZip = Join-Path $tempZipPath "cucumber-reports.zip"
                  Compress-Archive -Path "$cucumberReportsPath/*" -DestinationPath $cucumberReportsZip -Force
                  Write-Host "  ✓ Creado: cucumber-reports.zip"

                  # Adjuntar al Test Run
                  $fileContent = [System.IO.File]::ReadAllBytes($cucumberReportsZip)
                  $base64Content = [System.Convert]::ToBase64String($fileContent)
                  $attachmentBody = @{
                      stream = $base64Content
                      fileName = "cucumber-reports.zip"
                      comment = "Karate HTML Reports"
                      attachmentType = "GeneralAttachment"
                  } | ConvertTo-Json
                  $attachmentUrl = "$orgUrl/$project/_apis/test/runs/$testRunId/attachments?api-version=7.0"
                  Invoke-RestMethod -Uri $attachmentUrl -Method Post -Headers $headers -Body $attachmentBody | Out-Null
                  Write-Host "  ✓ Adjuntado: cucumber-reports.zip al Test Run"
              } catch {
                  Write-Host "  ⚠ Error con cucumber-reports.zip: $($_.Exception.Message)"
              }
          } else {
              Write-Host "  ⚠ No se encontró: cucumber-reports/"
          }

          # Limpiar directorio temporal
          Remove-Item -Path $tempZipPath -Recurse -Force -ErrorAction SilentlyContinue

          Write-Host "`n✓ Reportes comprimidos y adjuntados al Test Run"

          # Completar el Test Run
          Write-Host "`nCompletando Test Run $testRunId..."
          $updateRunBody = @{
              state = "Completed"
          } | ConvertTo-Json

          $updateRunUrl = "$orgUrl/$project/_apis/test/runs/$($testRunId)?api-version=7.0"
          Write-Host "URL: $updateRunUrl"

          try {
              Invoke-RestMethod -Uri $updateRunUrl -Method Patch -Headers $headers -Body $updateRunBody
              Write-Host "✓ Test Run $testRunId completado"
          } catch {
              Write-Host "⚠ Error al completar Test Run: $($_.Exception.Message)"
          }

          Write-Host "`n========================================"
          Write-Host "RESUMEN FINAL:"
          Write-Host "========================================"
          Write-Host "Test Run ID: $testRunId"
          Write-Host "Total Iteraciones: $($allIterations.Count)"
          Write-Host "URL: $orgUrl/$project/_testManagement/runs?runId=$testRunId&_a=resultSummary"
          Write-Host "========================================"
      } else {
          Write-Host "✗ ERROR: No se encontraron resultados para publicar"
          exit 1
      }
  displayName: 'Associate Test Results with Azure Test Plan'
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)

- task: PublishBuildArtifacts@1
  condition: always()
  inputs:
    PathtoPublish: '$(Build.SourcesDirectory)/target'
    ArtifactName: 'test-reports'
    publishLocation: 'Container'
  displayName: 'Publish All Test Reports'
